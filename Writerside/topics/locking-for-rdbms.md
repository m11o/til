ref: https://terasolunaorg.github.io/guideline/5.6.0.RELEASE/ja/ArchitectureInDetail/DataAccessDetail/ExclusionControl.html

# 排他制御の必要性

- 2つのトランザクションで同時に更新された場合に、整合性が崩れる
- 他トランザクションでロック中にデータ取得し、解放後に更新すると、他トランザクションで更新されたデータを上書きしてしまう

これらを解決するためには、処理を一列にすれば解決する。
デメリットとしては、単位時間内に実行可能なトランザクション数が減少するため、パフォーマンスが低下することになる。
-> 行ロックであればそこまで影響はない？

# 分離レベルによる排他制御

分離レベルによって、排他制御した際の挙動が変わる
以下３つ

- Dirty Read
- Non Repeatable Read
- Phantom Read

Dirty Readは、他トランザクションのコミットしていないデータを読み込むことができる
Non Repeatable Readは、同一トランザクション内で同じデータを2回読み込んだ場合、1回目と2回目に別トランザクションで更新があった場合に、2回目で取得できる値が異なる可能性がある。
Phantom Readは、同一トランザクション内で同じクエリを2回実行した場合、1回目と2回目で別トランザクションでレコードの追加や削除があった場合に、2回目で取得できるレコードが異なる可能性がある。