# 配列とスライスの違い

## 配列

- 固定長
- 配列の型や数が異なれば異なる型として扱われる
- 配列は、別の変数に代入すると、コピーされてアドレスが異なる
  - インスタンス自体を渡す場合には、ポインタで渡す必要がある
- 値として扱われる
  - 型が同じであれば `==` で比較できる

## スライス

- 可変長
- makeで宣言可能
  - 第一引数は、スライスの長さ
  - 第二引数は、スライスの容量
- スライスの容量以上の長さになると、容量が自動的に拡張される
- 複製する場合には、copy関数を使用する
- 比較ができない
- slice packagesを使用すれば複製や比較を行うことができる
  - https://pkg.go.dev/slices

配列は固定長。スライスは可変長。
配列は、配列の型や数が異なれば異なる型として扱われる。また、配列は

配列の宣言方法

```go
array1 := [5]int {1, 2, 3, 4, 5}
array2 := [...]int {1, 2, 3, 4, 5}
```

スライスの宣言方法

第一引数は、スライスの長さ。第二引数は、スライスの容量。
スライスの容量以上の長さになると、容量が自動的に拡張される。

```go
slice1 := make([]int, 5)
slice2 := make([]int, 5, 10)
slice3 := []int{1, 2, 3}
```

また、配列からsliceを作成することもできる

```go
array := [5]int{1, 2, 3, 4, 5}
slice := array[:]
```

## 違い

配列には、後から要素を追加することができない。スライスは、後から要素を追加することができる。

```go
array = [5]int{1, 2, 3, 4, 5}
array = append(array, 6) // error

slice = make([]int, 5)
slice = append(slice, 6) // ok
```

変数への代入の挙動が異なる

配列は、別の変数に代入すると、コピーされてアドレスが異なる。
sliceは、別の変数に代入すると、アドレスが同じになる。

したがって、別の変数に代入した配列を変更した場合、
配列は、代入前の配列は変更されないが、スライスは代入前のスライスも変更される

```go
// array

array0 := [...]int{1, 2, 3, 4}
array1 := array0

>> array0: [1 2 3 4]
>> array1: [1 2 3 4]
>> &array0[0]: 0xc00000a360
>> &array1[0]: 0xc00000a380

array0[0] = 5

>> array0: [5 2 3 4]
>> array1: [1 2 3 4]

// slice

slice0 := []int{1,2,3,4}
slice1 := slice0

>> slice0: [1 2 3 4]
>> slice1: [1 2 3 4]
>> &slice0[0]: 0xc000058100
>> &slice1[0]: 0xc000058100

slice0[0] = 5

>> slice0: [5 2 3 4]
>> slice1: [5 2 3 4]
```